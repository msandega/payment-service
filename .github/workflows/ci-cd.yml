name: CI/CD - Payments API (Network Fixed)

on:
  workflow_dispatch: {}
  push:
    branches: [ "main-default", "trial" ]
  pull_request:
    branches: [ "main-default", "trial" ]

env:
  IMAGE_PAYMENT: ranckosolutionsinc/payments-service
  IMAGE_TAG: v1.0

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Create a Docker network
        run: docker network create ci-network || true

      - name: Start Mongo (test DB)
        run: |
          docker run -d --name ci-mongo --network ci-network \
            -e MONGO_INITDB_ROOT_USERNAME=mongo \
            -e MONGO_INITDB_ROOT_PASSWORD=password \
            mongo:4.2

      - name: Wait for MongoDB to be ready
        run: |
          echo "Waiting for MongoDB to be ready..."
          for i in $(seq 1 30); do
            if docker exec ci-mongo mongo --host localhost:27017 --username mongo --password password --authenticationDatabase admin --eval "db.runCommand('ping')" >/dev/null 2>&1; then
              echo "MongoDB is ready!"
              break
            fi
            echo "Waiting for MongoDB... (attempt $i/30)"
            sleep 2
          done

      - name: Pull payment image
        run: docker pull ${{ env.IMAGE_PAYMENT }}:${{ env.IMAGE_TAG }}

      # SOLUTION 1: Use host network mode
      - name: Run payment container (host network)
        env:
          MONGODB_URI: mongodb://mongo:password@localhost:27017/?authSource=admin
        run: |
          # Start MongoDB on host network for easier access
          docker rm -f ci-mongo || true
          docker run -d --name ci-mongo \
            -p 27017:27017 \
            -e MONGO_INITDB_ROOT_USERNAME=mongo \
            -e MONGO_INITDB_ROOT_PASSWORD=password \
            mongo:4.2
          
          # Wait for MongoDB
          sleep 10
          
          # Start payment service on host network
          docker run -d \
            --name ci-payment \
            --network host \
            -e MONGODB_URI="mongodb://mongo:password@127.0.0.1:27017/?authSource=admin" \
            -e INTASEND_PUBLIC_KEY="${{ secrets.CI_INTASEND_PUBLIC_KEY }}" \
            -e INTASEND_SECRET_KEY="${{ secrets.CI_INTASEND_SECRET_KEY }}" \
            -e INTASEND_TEST_MODE=true \
            ${{ env.IMAGE_PAYMENT }}:${{ env.IMAGE_TAG }}

      # SOLUTION 2: Alternative - Use docker exec for health checks
      - name: Alternative health check (using docker exec)
        run: |
          echo "=== Container-based health check ==="
          
          # Wait for service to start
          sleep 15
          
          # Check if container is running
          if docker ps --filter name=ci-payment --format "{{.Names}}" | grep -q ci-payment; then
            echo "‚úÖ Container is running"
            
            # Try health check from inside the container
            for i in $(seq 1 20); do
              echo "Health check attempt $i..."
              
              # Method 1: Use docker exec to curl from inside container
              if docker exec ci-payment curl -sS -m 5 http://localhost:3663/health >/dev/null 2>&1; then
                echo "‚úÖ Health check passed (via docker exec to localhost)"
                break
              elif docker exec ci-payment curl -sS -m 5 http://127.0.0.1:3663/health >/dev/null 2>&1; then
                echo "‚úÖ Health check passed (via docker exec to 127.0.0.1)"
                break
              elif docker exec ci-payment curl -sS -m 5 http://0.0.0.0:3663/health >/dev/null 2>&1; then
                echo "‚úÖ Health check passed (via docker exec to 0.0.0.0)"
                break
              # Method 2: Direct localhost from host (should work with --network host)
              elif curl -sS -m 5 http://localhost:3663/health >/dev/null 2>&1; then
                echo "‚úÖ Health check passed (host localhost)"
                break
              # Method 3: Try different endpoints
              elif curl -sS -m 5 http://127.0.0.1:3663/ >/dev/null 2>&1; then
                echo "‚úÖ Root endpoint accessible"
                break
              fi
              
              sleep 3
            done
          else
            echo "‚ùå Container is not running"
            docker ps -a --filter name=ci-payment
            docker logs ci-payment || true
            exit 1
          fi

      # SOLUTION 3: Network inspection and debugging
      - name: Network debugging
        run: |
          echo "=== Network Debugging Information ==="
          
          echo "1. Container status:"
          docker ps -a --filter name=ci-payment
          
          echo "2. Container logs:"
          docker logs ci-payment || true
          
          echo "3. Network information:"
          docker inspect ci-payment --format '{{.NetworkSettings.IPAddress}}' || true
          docker inspect ci-payment --format '{{.NetworkSettings.Ports}}' || true
          
          echo "4. Port binding check:"
          netstat -tlnp | grep 3663 || echo "No process binding to port 3663"
          
          echo "5. Container process list:"
          docker exec ci-payment ps aux || true
          
          echo "6. Test different network approaches:"
          
          # Get container IP
          CONTAINER_IP=$(docker inspect ci-payment --format '{{.NetworkSettings.IPAddress}}' 2>/dev/null || echo "")
          if [ ! -z "$CONTAINER_IP" ]; then
            echo "Container IP: $CONTAINER_IP"
            curl -sS -m 5 "http://$CONTAINER_IP:3663/health" || echo "Container IP health check failed"
          fi
          
          # Test Docker gateway
          GATEWAY_IP=$(docker network inspect bridge --format '{{(index .IPAM.Config 0).Gateway}}' 2>/dev/null || echo "172.17.0.1")
          echo "Gateway IP: $GATEWAY_IP"
          
          # Test host.docker.internal (if available)
          curl -sS -m 5 http://host.docker.internal:3663/health 2>/dev/null || echo "host.docker.internal not available"

      - name: Comprehensive endpoint testing
        run: |
          echo "=== Testing all possible endpoints and methods ==="
          
          # Test different hosts and endpoints
          HOSTS=("localhost" "127.0.0.1" "0.0.0.0")
          ENDPOINTS=("/" "/health" "/healthz" "/api/health" "/status" "/ping")
          
          for host in "${HOSTS[@]}"; do
            for endpoint in "${ENDPOINTS[@]}"; do
              echo "Testing http://$host:3663$endpoint"
              if curl -sS -m 3 "http://$host:3663$endpoint" 2>/dev/null; then
                echo "‚úÖ SUCCESS: $host$endpoint"
              else
                echo "‚ùå FAILED: $host$endpoint"
              fi
            done
          done

      - name: Final service validation
        run: |
          echo "=== Final Service Validation ==="
          
          # Check if we can get ANY response from the service
          SUCCESS=false
          
          # Try multiple approaches
          if curl -sS -m 5 http://localhost:3663/ >/dev/null 2>&1; then
            echo "‚úÖ Service responding on localhost"
            SUCCESS=true
          elif curl -sS -m 5 http://127.0.0.1:3663/ >/dev/null 2>&1; then
            echo "‚úÖ Service responding on 127.0.0.1"
            SUCCESS=true
          elif docker exec ci-payment curl -sS -m 5 http://localhost:3663/ >/dev/null 2>&1; then
            echo "‚úÖ Service responding internally"
            SUCCESS=true
          fi
          
          if [ "$SUCCESS" = false ]; then
            echo "‚ùå Service validation failed - dumping all debug info"
            echo "Container logs:"
            docker logs ci-payment
            echo "Container inspect:"
            docker inspect ci-payment
            exit 1
          else
            echo "üéâ Service validation passed!"
          fi

      - name: Cleanup containers (always)
        if: always()
        run: |
          echo "=== Cleaning up containers ==="
          docker rm -f ci-payment ci-mongo || true
          docker network rm ci-network || true
          echo "Cleanup completed"